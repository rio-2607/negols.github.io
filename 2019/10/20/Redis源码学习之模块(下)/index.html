<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Redis,源码,">










<meta name="description" content="Why在Redis源码学习之模块(上)这篇文章中提到过，所有的Redis模块的入口函数都是RedisModule_OnLoad()方法，那么这个方法什么时候被调用呢？传入的参数是什么样的呢？自定义的模块命令的实现是如何被调用的？这篇文章就一一为你揭秘。 模块加载在前文中，我们提到了在Redis中有两种方式加载自定义的模块，一种是在Redis运行之前在配置文件中使用loadmodule /path/">
<meta name="keywords" content="Redis,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis模块学习(下):Why">
<meta property="og:url" content="http://yoursite.com/2019/10/20/Redis源码学习之模块(下)/index.html">
<meta property="og:site_name" content="天凉好个秋">
<meta property="og:description" content="Why在Redis源码学习之模块(上)这篇文章中提到过，所有的Redis模块的入口函数都是RedisModule_OnLoad()方法，那么这个方法什么时候被调用呢？传入的参数是什么样的呢？自定义的模块命令的实现是如何被调用的？这篇文章就一一为你揭秘。 模块加载在前文中，我们提到了在Redis中有两种方式加载自定义的模块，一种是在Redis运行之前在配置文件中使用loadmodule /path/">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2019/10/29/MhReWaGUFSz7Krx.png">
<meta property="og:updated_time" content="2019-10-30T14:25:10.723Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis模块学习(下):Why">
<meta name="twitter:description" content="Why在Redis源码学习之模块(上)这篇文章中提到过，所有的Redis模块的入口函数都是RedisModule_OnLoad()方法，那么这个方法什么时候被调用呢？传入的参数是什么样的呢？自定义的模块命令的实现是如何被调用的？这篇文章就一一为你揭秘。 模块加载在前文中，我们提到了在Redis中有两种方式加载自定义的模块，一种是在Redis运行之前在配置文件中使用loadmodule /path/">
<meta name="twitter:image" content="https://i.loli.net/2019/10/29/MhReWaGUFSz7Krx.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/10/20/Redis源码学习之模块(下)/">





  <title>Redis模块学习(下):Why | 天凉好个秋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">天凉好个秋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/20/Redis源码学习之模块(下)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Slogen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天凉好个秋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis模块学习(下):Why</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-20T21:04:45+08:00">
                2019-10-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/20/Redis源码学习之模块(下)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/10/20/Redis源码学习之模块(下)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>在<a href="http://slogen.xyz/2019/10/17/Redis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%28%E4%B8%8A%29/" target="_blank" rel="noopener">Redis源码学习之模块(上)</a>这篇文章中提到过，所有的Redis模块的入口函数都是<code>RedisModule_OnLoad()</code>方法，那么这个方法什么时候被调用呢？传入的参数是什么样的呢？自定义的模块命令的实现是如何被调用的？这篇文章就一一为你揭秘。</p>
<h4 id="模块加载"><a href="#模块加载" class="headerlink" title="模块加载"></a>模块加载</h4><p>在前文中，我们提到了在Redis中有两种方式加载自定义的模块，一种是在Redis运行之前在配置文件中使用<code>loadmodule /path/to/module.so</code>指令，另一种是在Redis的运行时使用<code>module load /path/to/module.so</code>命令来加载。</p>
<h5 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h5><p>既然是从配置文件加载，那么入口肯定是读取配置文件。<code>server.c</code>的<code>main()</code>函数简化(只保留了跟模块相关的代码)如下 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    int j;</span><br><span class="line"></span><br><span class="line">    // .... 一些省略代码</span><br><span class="line"></span><br><span class="line">    // 初始化模块系统</span><br><span class="line">    moduleInitModulesSystem();</span><br><span class="line"></span><br><span class="line">    // ... 一些省略代码</span><br><span class="line"></span><br><span class="line">    if (argc &gt;= 2) &#123;</span><br><span class="line">        // ... 一些省略代码</span><br><span class="line">        resetServerSaveParams();</span><br><span class="line">        // 读取配置文件的配置信息</span><br><span class="line">        loadServerConfig(configfile,options);</span><br><span class="line"></span><br><span class="line">        sdsfree(options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ....一些省略代码</span><br><span class="line"></span><br><span class="line">    if (!server.sentinel_mode) &#123;</span><br><span class="line"></span><br><span class="line">        // ... 一些省略代码</span><br><span class="line"></span><br><span class="line">        // 从队列中加载模块</span><br><span class="line">        moduleLoadFromQueue();</span><br><span class="line"></span><br><span class="line">        // ... 一些省略代码</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ... 一些省略代码</span><br><span class="line"></span><br><span class="line">    aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line">    aeSetAfterSleepProc(server.el,afterSleep);</span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>main()</code>中会调用<code>loadServerConfig()</code>方法从配置文件中读取配置信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void loadServerConfig(char *filename, char *options) &#123;</span><br><span class="line">    // 其他省略代码</span><br><span class="line">    loadServerConfigFromString(config);// 读取配置信息</span><br><span class="line">    sdsfree(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>loadServerConfig()</code>调用<code>loadServerConfigFromString()</code>完成具体的配置信息的读取，<code>loadServerConfigFromString()</code>的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void loadServerConfigFromString(char *config) &#123;</span><br><span class="line">    char *err = NULL;</span><br><span class="line">    int linenum = 0, totlines, i;</span><br><span class="line">    int slaveof_linenum = 0;</span><br><span class="line">    sds *lines;</span><br><span class="line"></span><br><span class="line">    lines = sdssplitlen(config,strlen(config),&quot;\n&quot;,1,&amp;totlines);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; totlines; i++) &#123;</span><br><span class="line">        sds *argv;</span><br><span class="line">        int argc;</span><br><span class="line"></span><br><span class="line">        linenum = i+1;</span><br><span class="line">        lines[i] = sdstrim(lines[i],&quot; \t\r\n&quot;);</span><br><span class="line"></span><br><span class="line">        // ....一些省略代码</span><br><span class="line"></span><br><span class="line">        /* Execute config directives */</span><br><span class="line">        if (!strcasecmp(argv[0],&quot;timeout&quot;) &amp;&amp; argc == 2) &#123;</span><br><span class="line">            server.maxidletime = atoi(argv[1]);</span><br><span class="line">            if (server.maxidletime &lt; 0) &#123;</span><br><span class="line">                err = &quot;Invalid timeout value&quot;; goto loaderr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; // .... 一些省略代码</span><br><span class="line">        else if (!strcasecmp(argv[0],&quot;loadmodule&quot;) &amp;&amp; argc &gt;= 2) &#123;</span><br><span class="line">            // 遇见了loadmodule指令，则表明需要加载自定义的模块</span><br><span class="line">            queueLoadModule(argv[1],&amp;argv[2],argc-2);</span><br><span class="line">        &#125; else if (!strcasecmp(argv[0],&quot;sentinel&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // ... 一些省略代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，如果发现配置文件中的某一行配置的第一个参数是<code>loadmodule</code>，则会调用<code>queueLoadModule()</code>方法完成加载模块的信息的收集，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void queueLoadModule(sds path, sds *argv, int argc) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    struct moduleLoadQueueEntry *loadmod;</span><br><span class="line"></span><br><span class="line">    loadmod = zmalloc(sizeof(struct moduleLoadQueueEntry));</span><br><span class="line">    loadmod-&gt;argv = zmalloc(sizeof(robj*)*argc);</span><br><span class="line">    loadmod-&gt;path = sdsnew(path);</span><br><span class="line">    loadmod-&gt;argc = argc;</span><br><span class="line">    for (i = 0; i &lt; argc; i++) &#123;</span><br><span class="line">        loadmod-&gt;argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    listAddNodeTail(server.loadmodule_queue,loadmod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>queueLoadModule()</code>方法会把需要加载的模块的信息(模块的路径、模块的参数、参数个数)封装成<code>moduleLoadQueueEntry</code>结构体，然后保存在<code>server.loadmodule_queue</code>列表中。</p>
<p>在读取完配置文件之后，<code>main()</code>会调用<code>moduleLoadFromQueue()</code>方法从队列找那个加载模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void moduleLoadFromQueue(void) &#123;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    listRewind(server.loadmodule_queue,&amp;li);</span><br><span class="line">    // 循环遍历server.loadmodule_queue列表，依次加载各个模块</span><br><span class="line">    while((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        struct moduleLoadQueueEntry *loadmod = ln-&gt;value;</span><br><span class="line">        if (moduleLoad(loadmod-&gt;path,(void **)loadmod-&gt;argv,loadmod-&gt;argc)</span><br><span class="line">            == C_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                &quot;Can&apos;t load module from %s: server aborting&quot;,</span><br><span class="line">                loadmod-&gt;path);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>moduleLoadFromQueue()</code>方法中会循环遍历<code>server.loadmodule_queue</code>列表(配置文件中配置的需要加载的模块都保存在这个列表上)，依次调用<code>moduleLoad()</code>方法来完成实际的模块加载动作。</p>
<p>在分析<code>moduleLoad()</code>方法之前，先来了解下在<code>*nix</code>平台上如何加载动态链接库。</p>
<p>在<code>*nix</code>平台上，使用gcc把源码编译成动态链接库的时候，需要使用<code>-shared</code>参数，一般同时也需要加上<code>-fPIC</code>选项，其中<code>-fPIC</code>选项的作用是：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的，所以动态载入时是通过代码拷贝的方式来满足不同的调用，而不能达到真正的代码段共享的目的。</p>
<p>同时<code>*inx</code>平台提供了<code>dl*</code>系列函数来使用动态链接库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">void *dlopen(const char *filename, int flag);</span><br><span class="line"></span><br><span class="line">char *dlerror(void);</span><br><span class="line"></span><br><span class="line">void *dlsym(void *handle, const char *symbol);</span><br><span class="line"></span><br><span class="line">int dlclose(void *handle);</span><br></pre></td></tr></table></figure>
<p><code>dlopen</code>以指定模式打开指定的动态链接库文件，并返回一个句柄给调用线程，<code>dlerror()</code>返回出现的错误，<br><code>dlsym</code>通过句柄和连接符名称获取函数名和变量名，并返回对应的指针，<code>dlclose()</code>来卸载打开的库。其中<code>dllopen</code>支持的模式有:</p>
<ul>
<li><code>RTLD_LAZY</code>: 暂缓决定，等有需要时再解出符号。</li>
<li><code>RTLD_NOW</code>: 立即决定，返回前解除所有未决定的符号。</li>
</ul>
<p>继续来看<code>moduleLoad()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int moduleLoad(const char *path, void **module_argv, int module_argc) &#123;</span><br><span class="line">    int (*onload)(void *, void **, int);</span><br><span class="line">    void *handle;</span><br><span class="line">    RedisModuleCtx ctx = REDISMODULE_CTX_INIT; // RedisModuleCtx对象初始值</span><br><span class="line"></span><br><span class="line">    // 调用dlopen打开动态链接库</span><br><span class="line">    handle = dlopen(path,RTLD_NOW|RTLD_LOCAL);</span><br><span class="line">    if (handle == NULL) &#123;</span><br><span class="line">        serverLog(LL_WARNING, &quot;Module %s failed to load: %s&quot;, path, dlerror());</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    onload = (int (*)(void *, void **, int))(unsigned long) dlsym(handle,&quot;RedisModule_OnLoad&quot;);</span><br><span class="line">    if (onload == NULL) &#123;</span><br><span class="line">        dlclose(handle);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            &quot;Module %s does not export RedisModule_OnLoad() &quot;</span><br><span class="line">            &quot;symbol. Module not loaded.&quot;,path);</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    // 实际上就是调用RedisModule_OnLoad()</span><br><span class="line">    if (onload((void*)&amp;ctx,module_argv,module_argc) == REDISMODULE_ERR) &#123;</span><br><span class="line">        if (ctx.module) &#123;</span><br><span class="line">            moduleUnregisterCommands(ctx.module);</span><br><span class="line">            moduleUnregisterSharedAPI(ctx.module);</span><br><span class="line">            moduleUnregisterUsedAPI(ctx.module);</span><br><span class="line">            moduleFreeModuleStructure(ctx.module);</span><br><span class="line">        &#125;</span><br><span class="line">        dlclose(handle);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            &quot;Module %s initialization failed. Module not loaded&quot;,path);</span><br><span class="line">        return C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Redis module loaded! Register it. */</span><br><span class="line">    dictAdd(modules,ctx.module-&gt;name,ctx.module);</span><br><span class="line">    ctx.module-&gt;handle = handle;</span><br><span class="line">    serverLog(LL_NOTICE,&quot;Module &apos;%s&apos; loaded from %s&quot;,ctx.module-&gt;name,path);</span><br><span class="line">    moduleFreeContext(&amp;ctx);</span><br><span class="line">    return C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>moduleLoad()</code>方法中，首先会调用<code>dlopen()</code>打开指定路径的动态链接库，获得句柄，然后调用<code>dlsym()</code>方法来查找是否存在<code>RedisModule_OnLoad</code>方法。如果存在的话，则获取<code>RedisModule_OnLoad()</code>函数的指针保存在<code>onload</code>指针上，接着调用<code>onload()</code>方法，实际上就是调用动态链接库中的<code>RedisModule_OnLoad()</code>方法。</p>
<p><strong>这里就解释了为什么所有的Redis模块都需要实现<code>RedisModule_OnLoad()</code>方法：Redis模块系统默认会去查找动态链接库里面的<code>RedisModule_OnLoad()</code>方法然后进行调用。</strong></p>
<p>如果<code>onload()</code>(也就是<code>RedisModule_OnLoad()</code>)调用没有出错的话，接下来会调用<code>dictAdd()</code>方法把新加载的模块保存在<code>modules</code>这个静态字典上，key为模块的名字，值为对应的模块对象的指针。接着释放内存，返回结果。</p>
<h5 id="运行时加载"><a href="#运行时加载" class="headerlink" title="运行时加载"></a>运行时加载</h5><p>运行时加载是指在Redis服务器已经启动成功之后执行<code>module load /path/to/module.so</code>指令来加载模块。执行上述命令的时候实际上是调用<code>moduleCommand()</code>方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void moduleCommand(client *c) &#123;</span><br><span class="line">    char *subcmd = c-&gt;argv[1]-&gt;ptr;</span><br><span class="line">    if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(subcmd,&quot;help&quot;)) &#123;</span><br><span class="line">      // help 命令</span><br><span class="line">    &#125; else</span><br><span class="line">    if (!strcasecmp(subcmd,&quot;load&quot;) &amp;&amp; c-&gt;argc &gt;= 3) &#123;</span><br><span class="line">        // load命令</span><br><span class="line">        robj **argv = NULL;</span><br><span class="line">        int argc = 0;</span><br><span class="line"></span><br><span class="line">        if (c-&gt;argc &gt; 3) &#123;</span><br><span class="line">            argc = c-&gt;argc - 3;</span><br><span class="line">            argv = &amp;c-&gt;argv[3];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 调用moduleLoad()方法加载模块</span><br><span class="line">        if (moduleLoad(c-&gt;argv[2]-&gt;ptr,(void **)argv,argc) == C_OK)</span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">        else</span><br><span class="line">            addReplyError(c,</span><br><span class="line">                &quot;Error loading the extension. Please check the server logs.&quot;);</span><br><span class="line">    &#125; else if (!strcasecmp(subcmd,&quot;unload&quot;) &amp;&amp; c-&gt;argc == 3) &#123;</span><br><span class="line">        // .... 省略代码，执行module unload 操作</span><br><span class="line">    &#125; else if (!strcasecmp(subcmd,&quot;list&quot;) &amp;&amp; c-&gt;argc == 2) &#123;</span><br><span class="line">        // .... 省略代码，执行module list操作</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        addReplySubcommandSyntaxError(c);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以很清楚地看到，<code>moduleCommand()</code>方法发现需要执行<code>load</code>操作时会直接调用<code>moduleLoad()</code>方法来执行具体的模块加载操作。</p>
<h4 id="RedisModule-Init"><a href="#RedisModule-Init" class="headerlink" title="RedisModule_Init()"></a><code>RedisModule_Init()</code></h4><p>在<a href="http://slogen.xyz/2019/10/17/Redis%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%28%E4%B8%8A%29/" target="_blank" rel="noopener">Redis源码学习之模块(上)</a>这篇文章中提到过在<code>RedisModule_OnLoad()</code>方法中首先要调用<code>RedisModule_Init()</code>方法，那么为什么呢？<code>RedisModule_Init()</code>主要执行什么操作呢？</p>
<p>别急，且听我娓娓道来。</p>
<p>首先看<code>RedisModule_Init()</code>方法，在<code>redismodule.h</code>文件中定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int RedisModule_Init(RedisModuleCtx *ctx, const char *name, int ver, int apiver) &#123;</span><br><span class="line">    // 获得传入的上下文对象的ctx的首地址</span><br><span class="line">    void *getapifuncptr = ((void**)ctx)[0];</span><br><span class="line">    RedisModule_GetApi = (int (*)(const char *, void *)) (unsigned long)getapifuncptr;</span><br><span class="line">    REDISMODULE_GET_API(Alloc);</span><br><span class="line">    // .... 其他省略注册代码</span><br><span class="line">  #ifdef REDISMODULE_EXPERIMENTAL_API</span><br><span class="line">    REDISMODULE_GET_API(GetThreadSafeContext);</span><br><span class="line">    // .... 其他省略注册代码</span><br><span class="line">  #endif</span><br><span class="line">    if (RedisModule_IsModuleNameBusy &amp;&amp; RedisModule_IsModuleNameBusy(name)) return REDISMODULE_ERR;</span><br><span class="line">    RedisModule_SetModuleAttribs(ctx,name,ver,apiver);</span><br><span class="line">    return REDISMODULE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>RedisModule_Init()</code>方法中首先把传入的<code>RedisModuleCtx</code>对象<code>ctx</code>的首地址赋值给<code>getapifuncptr</code>指针，那么<code>ctx</code>的首地址指向哪里呢？</p>
<p><code>ctx</code>对象是在调用<code>RedisModule_OnLoad()</code>方法时传入的，初始化为<code>REDISMODULE_CTX_INIT</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define REDISMODULE_CTX_INIT &#123;(void*)(unsigned long)&amp;RM_GetApi, NULL, NULL, NULL, NULL, 0, 0, 0, NULL, 0, NULL, NULL, 0, NULL&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到,<code>ctx</code>的首地址指向<code>RM_GetApi()</code>方法，<code>RM_GetApi</code>定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int RM_GetApi(const char *funcname, void **targetPtrPtr) &#123;</span><br><span class="line">  dictEntry *he = dictFind(server.moduleapi, funcname);</span><br><span class="line">  if (!he) return REDISMODULE_ERR;</span><br><span class="line">  *targetPtrPtr = dictGetVal(he);</span><br><span class="line">  return REDISMODULE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>RM_GetApi</code>方法从<code>server.moduleapi</code>字典中查找对应的方法,那么<code>server.moduleapi</code>字段的数据是在什么时候赋值的呢？</p>
<p>在<code>module.c</code>文件中有一个函数<code>moduleRegisterCoreAPI()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void moduleRegisterCoreAPI(void) &#123;</span><br><span class="line">    server.moduleapi = dictCreate(&amp;moduleAPIDictType,NULL);</span><br><span class="line">    server.sharedapi = dictCreate(&amp;moduleAPIDictType,NULL);</span><br><span class="line">    REGISTER_API(Alloc);</span><br><span class="line">    REGISTER_API(Calloc);</span><br><span class="line">    REGISTER_API(Realloc);</span><br><span class="line">    // 其他省略的导出方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中会初始化<code>server.moduleapi</code>列表，并且会调用<code>REGISTER_API</code>宏来向<code>moduleapi</code>字典中添加需要导出的方法，<code>REGISTER_API</code>宏定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define REGISTER_API(name) moduleRegisterApi(&quot;RedisModule_&quot; #name, (void *)(unsigned long)RM_ ## name)</span><br></pre></td></tr></table></figure>
<p>这个宏定义会把传入的名称进行转换，添加<code>RedisModule_</code>前缀作为方法名，<code>RM_</code>前缀的方法作为回调方法（比如传入的名称是<code>Alloc</code>，则转换之后的方法名是<code>RedisModule_Alloc</code>，对应的回调方法为<code>RM_Alloc</code>）调用<code>moduleRegisterApi</code>方法,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int moduleRegisterApi(const char *funcname, void *funcptr) &#123;</span><br><span class="line">    return dictAdd(server.moduleapi, (char*)funcname, funcptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>moduleRegisterApi()</code>直接往<code>moduleapi</code>字典中添加数据。<br>那么<code>moduleRegisterCoreAPI()</code>方法是在什么时候被调用的呢？</p>
<p>答：在<code>server.c</code>的<code>main()</code>函数中，调用<code>initServerConfig()</code>初始化服务端配置之后，会新调用<code>moduleInitModuleSystem()</code>方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void moduleInitModulesSystem(void) &#123;</span><br><span class="line"></span><br><span class="line">    // 其他省略代码</span><br><span class="line"></span><br><span class="line">    moduleRegisterCoreAPI();</span><br><span class="line"></span><br><span class="line">    // 其他省略代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>moduleInitModulesSystem()</code>方法中会调用<code>moduleRegisterCoreAPI()</code>完成导出方法的注册。</p>
<p>先总结一下：</p>
<ol>
<li>Redis服务器在启动的时候会调用<code>moduleRegisterCoreAPI()</code>方法，把Redis模块所有需要导出的方法注册到<code>server.moduleapi</code>字典上。</li>
<li>在调用<code>RedisModule_OnLoad()</code>方法时传入的<code>RedisModuleCtx</code>对象<code>ctx</code>的首地址指针指向<code>RM_GetApi()</code>方法，而<code>RM_GetApi()</code>方法的作用是从<code>server.moduleapi</code>字典中查找指定名称的方法。</li>
</ol>
<p>现在重新回到<code>RedisModule_Init()</code>方法中来:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int RedisModule_Init(RedisModuleCtx *ctx, const char *name, int ver, int apiver) &#123;</span><br><span class="line">    // 获得传入的上下文对象的ctx的首地址</span><br><span class="line">    void *getapifuncptr = ((void**)ctx)[0];</span><br><span class="line">    RedisModule_GetApi = (int (*)(const char *, void *)) (unsigned long)getapifuncptr;</span><br><span class="line">    REDISMODULE_GET_API(Alloc);</span><br><span class="line">    // .... 其他省略注册代码</span><br><span class="line">  #ifdef REDISMODULE_EXPERIMENTAL_API</span><br><span class="line">    REDISMODULE_GET_API(GetThreadSafeContext);</span><br><span class="line">    // .... 其他省略注册代码</span><br><span class="line">  #endif</span><br><span class="line">    if (RedisModule_IsModuleNameBusy &amp;&amp; RedisModule_IsModuleNameBusy(name)) return REDISMODULE_ERR;</span><br><span class="line">    RedisModule_SetModuleAttribs(ctx,name,ver,apiver);</span><br><span class="line">    return REDISMODULE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在把<code>ctx</code>的首地址指针赋值给<code>RedisModule_GetApi</code>(函数指针)之后，接下来是一长串的<code>REDISMODULE_GET_API()</code>调用。<code>REDISMODULE_GET_API</code>是个宏定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define REDISMODULE_GET_API(name) \</span><br><span class="line">    RedisModule_GetApi(&quot;RedisModule_&quot; #name, ((void **)&amp;RedisModule_ ## name))</span><br></pre></td></tr></table></figure></p>
<p>这个宏定义会把传入的名字加上<code>RedisModule_</code>前缀，然后调用<code>RedisModule_GetApi()</code>方法查找对应的方法，如果查找到的话，把查找到的结果保存在以<code>RedisModule_</code>为前缀的函数指针上，亦即导出了一个API。</p>
<p>假如传入<code>REDISMODULE_GET_API()</code>的是<code>Realloc</code>，则最终会调用<code>RedisModule_GetApi(&quot;RedisModule_Realloc&quot;,(void**)&amp;RedisModule_Realloc)</code>。<br>其效果就是在<code>server.moduleapi</code>字典中查找方法名为<code>RedisModule_Realloc</code>的方法，如果找到的话，则会把对应的函数指针赋值给<code>RedisModule_Realloc</code>字段上。</p>
<p>在执行完这句代码之后，<code>RedisModule_Realloc</code>实际上就是指向了<code>RM_Realloc()</code>方法。</p>
<p>换句话说，<code>RM_GetApi()</code>方法和<code>REDISMODULE_GET_API()</code>宏完成了Redis对外导出的方法的方法名称的映射:</p>
<table>
<thead>
<tr>
<th style="text-align:center">模块开发中可使用的API</th>
<th style="text-align:center">Redis本身的实现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>RedisModule_IsModuleNameBusy</code></td>
<td style="text-align:center"><code>RM_IsModuleNameBusy</code></td>
</tr>
<tr>
<td style="text-align:center"><code>RedisModule_SetModuleAttribs</code></td>
<td style="text-align:center"><code>RM_SetModuleAttribs</code></td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>在导出了一系列API之后，<code>RedisModule_Init()</code>方法紧接着会调用<code>RedisModule_IsModuleNameBusy()</code>(实际上就是<code>RM_IsModuleNameBusy()</code>)判断传入的模块名称是否已经存在，如果已经存在的话则直接报错返回，说明<strong>模块名称不能重复。</strong><br>接着会继续调用<code>RedisModule_SetModuleAttribs()</code>(<code>RM_SetModuleAttribs()</code>)完成<code>RedisModule</code>对象的的初始化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver) &#123;</span><br><span class="line">    RedisModule *module;</span><br><span class="line"></span><br><span class="line">    if (ctx-&gt;module != NULL) return;</span><br><span class="line">    module = zmalloc(sizeof(*module));</span><br><span class="line">    module-&gt;name = sdsnew((char*)name);</span><br><span class="line">    module-&gt;ver = ver;</span><br><span class="line">    module-&gt;apiver = apiver;</span><br><span class="line">    module-&gt;types = listCreate();</span><br><span class="line">    module-&gt;usedby = listCreate();</span><br><span class="line">    module-&gt;using = listCreate();</span><br><span class="line">    module-&gt;filters = listCreate();</span><br><span class="line">    module-&gt;in_call = 0;</span><br><span class="line">    ctx-&gt;module = module;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中会初始化<code>RedisModule</code>对象，并把指针保存在<code>ctx-&gt;module</code>字段中。</p>
<p>总结一下，在<code>RedisModule_Init()</code>方法中，主要完成了下面两件事：</p>
<ol>
<li>导出了Redis模块系统提供的API。</li>
<li>完成<code>RedisModule</code>对象的初始化并保存在上下文对象<code>RedisModuleCtx</code>的<code>module</code>字段中。</li>
</ol>
<h4 id="RedisModule-CreateCommand"><a href="#RedisModule-CreateCommand" class="headerlink" title="RedisModule_CreateCommand"></a><code>RedisModule_CreateCommand</code></h4><p>在<code>RedisModule_OnLoad()</code>实现中，调用完<code>RedisModule_Init()</code>之后紧接着调用了<code>RedisModule_CreateCommand()</code>来注册自定义的命令。</p>
<p><code>RedisModule_CreateCommand()</code>实际上指向<code>RM_CreateCommand()</code>方法:<code>RM_CreateCommand()</code>主要是初始化<code>RedisModuleCommandProxy</code>对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) &#123;</span><br><span class="line">    int flags = strflags ? commandFlagsFromString((char*)strflags) : 0;</span><br><span class="line">    if (flags == -1) return REDISMODULE_ERR;</span><br><span class="line">    if ((flags &amp; CMD_MODULE_NO_CLUSTER) &amp;&amp; server.cluster_enabled)</span><br><span class="line">        return REDISMODULE_ERR;</span><br><span class="line"></span><br><span class="line">    struct redisCommand *rediscmd;</span><br><span class="line">    RedisModuleCommandProxy *cp;</span><br><span class="line">    sds cmdname = sdsnew(name);</span><br><span class="line"></span><br><span class="line">    /* Check if the command name is busy. */</span><br><span class="line">    if (lookupCommand(cmdname) != NULL) &#123;</span><br><span class="line">        sdsfree(cmdname);</span><br><span class="line">        return REDISMODULE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Create a command &quot;proxy&quot;, which is a structure that is referenced</span><br><span class="line">     * in the command table, so that the generic command that works as</span><br><span class="line">     * binding between modules and Redis, can know what function to call</span><br><span class="line">     * and what the module is.</span><br><span class="line">     *</span><br><span class="line">     * Note that we use the Redis command table &apos;getkeys_proc&apos; in order to</span><br><span class="line">     * pass a reference to the command proxy structure. */</span><br><span class="line">    cp = zmalloc(sizeof(*cp));</span><br><span class="line">    cp-&gt;module = ctx-&gt;module;</span><br><span class="line">    cp-&gt;func = cmdfunc; // 指向用户自定义的命令回调函数指针</span><br><span class="line">    cp-&gt;rediscmd = zmalloc(sizeof(*rediscmd));</span><br><span class="line">    cp-&gt;rediscmd-&gt;name = cmdname;</span><br><span class="line">    cp-&gt;rediscmd-&gt;proc = RedisModuleCommandDispatcher;</span><br><span class="line">    cp-&gt;rediscmd-&gt;arity = -1;</span><br><span class="line">    cp-&gt;rediscmd-&gt;flags = flags | CMD_MODULE;</span><br><span class="line">    cp-&gt;rediscmd-&gt;getkeys_proc = (redisGetKeysProc*)(unsigned long)cp; // 保存cp的指针</span><br><span class="line">    cp-&gt;rediscmd-&gt;firstkey = firstkey;</span><br><span class="line">    cp-&gt;rediscmd-&gt;lastkey = lastkey;</span><br><span class="line">    cp-&gt;rediscmd-&gt;keystep = keystep;</span><br><span class="line">    cp-&gt;rediscmd-&gt;microseconds = 0;</span><br><span class="line">    cp-&gt;rediscmd-&gt;calls = 0;</span><br><span class="line"></span><br><span class="line">    // 向命令表中添加自定义的命令,</span><br><span class="line">    dictAdd(server.commands,sdsdup(cmdname),cp-&gt;rediscmd);</span><br><span class="line">    dictAdd(server.orig_commands,sdsdup(cmdname),cp-&gt;rediscmd);</span><br><span class="line">    return REDISMODULE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行了相应的参数检查之后，就是对<code>RedisModuleCommandProxy</code>对象进行初始化，<code>RedisModuleCommandProxy</code>表示一个Redis模块命令的代理，用来把<code>RedisModule</code>、模块的回调实现跟<code>RedisComand</code>关联在一起。结构如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct RedisModuleCommandProxy &#123;</span><br><span class="line">    struct RedisModule *module; // 代表一个redis谋爱</span><br><span class="line">    RedisModuleCmdFunc func; // 命令回调方法</span><br><span class="line">    struct redisCommand *rediscmd; // redis命令</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对<code>RedisModuleCommandProxy</code>对象的初始化，主要就是生成<code>RedisCommand</code>对象，如果熟悉<code>Redis</code>源码的同学，对这个数据结构应该很熟悉，<code>RedisCommand</code>代表一个Redis的命令，每个<code>RedisCommand</code>对象都有个字段<code>proc</code>指向命令的回调方法，所有的<code>Redis</code>命令实际上最终都是调用<code>proc</code>指向的函数。</p>
<p>在<code>RM_CreateCommand()</code>中生成的<code>RedisCommand</code>对象的<code>proc</code>函数指针被赋值为<code>RedisModuleCommandDispatcher</code>。也就是说所有的模块命令执行的时候，最终都是调用<code>RedisModuleCommandDispatcher()</code>。</p>
<p>同时，生成的<code>RedisModuleCommandDispatcher</code>对象的指针被强制转换成<code>redisGetKeysProc*</code>类型保存在<code>RedisCommand</code>的<code>getkeys_proc</code>字段中。</p>
<p>其实这里的实现有一些巧妙：<code>getkeys_proc</code>指向的<code>redisGetKeysProc</code>类型的函数<strong>本意是用来从命令行参数中获取key</strong>，（一般只有在<code>firstkey</code>、<code>lastkey</code>和<code>keystep</code>这几个参数都不确定的情况下才需要使用，大部分命令都是<code>NULL</code>）。而在这里的实现中，把<code>RedisModuleCommandDispatcher</code>对象强制转换成<code>redisGetKeysProc*</code>保存在<code>getkeys_proc</code>字段中，相当于强制把<code>RedisComand</code>对象跟生成的<code>RedisModuleCommandProxy</code>关联在一起了(<code>RedisModuleCommandProxy</code>对象的<code>rediscmd</code>字段只是把<code>RedisModuleCommandProxy</code>跟<code>RedisCommand</code>进行了单向的关联)。因为当执行命令的时候，只能根据命令名称定位到对应的<code>RedisCommand</code>对象，而自定义的模块的回调保存在<code>RedisModuleCommandProxy</code>对象的<code>func</code>字段中，因此需要能够根据<code>RedisCommand</code>对象回溯到<code>func</code>函数。<br><strong>这里巧妙的地方在于复用了<code>getkeys_proc</code>字段，把这个字段当做一个指针容器，用来关联<code>RedisCommand</code>和<code>RedisModuleCommandProxy</code>。</strong></p>
<p>在完成<code>RedisModuleCommandProxy</code>的初始化之后，会调用<code>dictAdd()</code>把新生成的<code>RedisCommand</code>对象保存到<code>server.commands</code>字典中，熟悉Redis源码的同学应该都知道，这个字典中保存了所有的<code>Redis</code>支持的命令，在接收到命令请求的时候都需要根据命令名称到<code>server.commands</code>字段中查找对应的实现，然后执行<code>proc()</code>。</p>
<p>在执行完<code>RM_CreateCommand()</code>方法之后，内存中的结构如下:</p>
<p><img src="https://i.loli.net/2019/10/29/MhReWaGUFSz7Krx.png" alt="module.png"></p>
<p>前面说了，所有的Redis的命令，实际上都是执行<code>proc()</code>方法，而自定义的模块命令的<code>proc()</code>方法实际上指向<code>RedisModuleCommandDispatcher()</code>。<code>RedisModuleCommandDispatcher</code> 实现如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void RedisModuleCommandDispatcher(client *c) &#123;</span><br><span class="line">    RedisModuleCommandProxy *cp = (void*)(unsigned long)c-&gt;cmd-&gt;getkeys_proc;</span><br><span class="line">    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;</span><br><span class="line"></span><br><span class="line">    ctx.module = cp-&gt;module;</span><br><span class="line">    ctx.client = c;</span><br><span class="line">    cp-&gt;func(&amp;ctx,(void**)c-&gt;argv,c-&gt;argc);</span><br><span class="line">    moduleHandlePropagationAfterCommandCallback(&amp;ctx);</span><br><span class="line">    moduleFreeContext(&amp;ctx);</span><br><span class="line"></span><br><span class="line">    // 其他省略代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>RedisModuleCommandDispatcher()</code>的实现中，首先会把<code>getkeys_proc</code>字段指向的数据强类型转换成<code>RedisModuleCommandProxy</code>对象，然后调用<code>RedisModuleCommandProxy</code>对象的<code>func</code>函数指针指向的方法。而<code>func</code>指针正是指向了调用<code>RedisModule_CreateCommand()</code>时传入的模块命令的回调函数，在本例中，实际上就是执行<code>ListExtendFilter_RedisCommand()</code>方法。</p>
<p>因此，执行自定义模块命令的时候实际上执行的就是模块实现的回调方法。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><a href="https://itnext.io/redis-5-x-under-the-hood-3-writing-a-redis-module-43fa42a6367d" target="_blank" rel="noopener">Redis 5.X under the hood: 3 — Writing a Redis Module</a></li>
<li><a href="https://redis.io/topics/modules-intro" target="_blank" rel="noopener">Redis Modules: an introduction to the API</a></li>
<li><a href="https://redis.io/topics/modules-api-ref" target="_blank" rel="noopener">Modules API reference</a></li>
</ol>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>万一打赏了呢^_^</div>
  <button id="rewardButton" disable="enable" style="width: 80px;line-height: 38px;text-align: center;font-weight: bold;color: #fff;border-radius: 5px;
margin:0 20px 20px 0;position: relative;overflow: hidden;color: #8c96a0;text-shadow:1px 1px 1px #fff;border:1px solid #dce1e6;box-shadow: 0 1px 2px #fff inset,0 -1px 0 #a8abae inset;background: -webkit-linear-gradient(top,#f2f3f7,#e4e8ec);background: -moz-linear-gradient(top,#f2f3f7,#e4e8ec);background: linear-gradient(top,#f2f3f7,#e4e8ec);" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    打赏
  </button>
  <div id="QR" style="display: none;">
    
      <div id="wechat" style="display: inline-block;width:150px;height:150px">
        <img id="wechat_qr" src="/uploads/wechatpay.jpeg" alt="Slogen WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    
    
      <div id="alipay" style="display: inline-block;width:150px;height:150px">
        <img id="alipay_qr" src="/uploads/alipay.jpeg" alt="Slogen Alipay">
        <p>Alipay</p>
      </div>
    
    
  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
            <a href="/tags/源码/" rel="tag"># 源码</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/17/Redis源码学习之模块(上)/" rel="next" title="Redis模块学习(上):What And How">
                <i class="fa fa-chevron-left"></i> Redis模块学习(上):What And How
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/10/Java动态编译运行源码/" rel="prev" title="Java动态编译运行源码">
                Java动态编译运行源码 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpeg" alt="Slogen">
            
              <p class="site-author-name" itemprop="name">Slogen</p>
              <p class="site-description motion-element" itemprop="description">不骄不躁，韬光养晦。荣辱不惊，厚积薄发。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Why"><span class="nav-number">1.</span> <span class="nav-text">Why</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模块加载"><span class="nav-number">1.1.</span> <span class="nav-text">模块加载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#配置文件加载"><span class="nav-number">1.1.1.</span> <span class="nav-text">配置文件加载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#运行时加载"><span class="nav-number">1.1.2.</span> <span class="nav-text">运行时加载</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RedisModule-Init"><span class="nav-number">1.2.</span> <span class="nav-text">RedisModule_Init()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RedisModule-CreateCommand"><span class="nav-number">1.3.</span> <span class="nav-text">RedisModule_CreateCommand</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference"><span class="nav-number">2.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Slogen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Bb4EcKhqq3La7xJ59ip4Yv8W-gzGzoHsz',
        appKey: 'LpDWAjNpYUPqyA8rRfxDqfKD',
        placeholder: '指点江山，激扬文字',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
