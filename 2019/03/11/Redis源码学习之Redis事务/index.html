<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="源码分析,Redis,">










<meta name="description" content="Redis作为一个内存型数据库，同样支持传统数据库的事务特性。这篇文章会从源代码角度来分析Redis中事务的实现原理。 WhatRedis事务提供了一种将多个命令请求打包，然后一次性、按照顺序地执行多个命令的机制，并且在事务执行的期间，服务器不会中断事务而去执行其他不在事务中的命令请求，它会把事务中所有的命令都执行完毕才会去执行其他的命令。 HowRedis中提供了multi、discard、ex">
<meta name="keywords" content="源码分析,Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis源码学习之Redis事务">
<meta property="og:url" content="http://yoursite.com/2019/03/11/Redis源码学习之Redis事务/index.html">
<meta property="og:site_name" content="天凉好个秋">
<meta property="og:description" content="Redis作为一个内存型数据库，同样支持传统数据库的事务特性。这篇文章会从源代码角度来分析Redis中事务的实现原理。 WhatRedis事务提供了一种将多个命令请求打包，然后一次性、按照顺序地执行多个命令的机制，并且在事务执行的期间，服务器不会中断事务而去执行其他不在事务中的命令请求，它会把事务中所有的命令都执行完毕才会去执行其他的命令。 HowRedis中提供了multi、discard、ex">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2018/11/16/5bee3f86d1eeb.png">
<meta property="og:image" content="https://i.loli.net/2018/11/16/5bee3fabd0e6d.png">
<meta property="og:image" content="https://i.loli.net/2018/11/16/5bee405d99bc9.png">
<meta property="og:image" content="https://i.loli.net/2018/11/16/5bee4085be7b0.png">
<meta property="og:image" content="https://i.loli.net/2018/11/16/5bee40c9c8d03.png">
<meta property="og:image" content="https://i.loli.net/2018/11/16/5bee40f849cf6.png">
<meta property="og:updated_time" content="2019-03-11T05:46:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis源码学习之Redis事务">
<meta name="twitter:description" content="Redis作为一个内存型数据库，同样支持传统数据库的事务特性。这篇文章会从源代码角度来分析Redis中事务的实现原理。 WhatRedis事务提供了一种将多个命令请求打包，然后一次性、按照顺序地执行多个命令的机制，并且在事务执行的期间，服务器不会中断事务而去执行其他不在事务中的命令请求，它会把事务中所有的命令都执行完毕才会去执行其他的命令。 HowRedis中提供了multi、discard、ex">
<meta name="twitter:image" content="https://i.loli.net/2018/11/16/5bee3f86d1eeb.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/11/Redis源码学习之Redis事务/">





  <title>Redis源码学习之Redis事务 | 天凉好个秋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">天凉好个秋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/11/Redis源码学习之Redis事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Slogen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天凉好个秋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis源码学习之Redis事务</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T13:46:56+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/11/Redis源码学习之Redis事务/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/11/Redis源码学习之Redis事务/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><code>Redis</code>作为一个内存型数据库，同样支持传统数据库的事务特性。这篇文章会从源代码角度来分析<code>Redis</code>中事务的实现原理。</p>
<h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p><code>Redis</code>事务提供了一种将多个命令请求打包，然后一次性、按照顺序地执行多个命令的机制，并且在事务执行的期间，服务器不会中断事务而去执行其他不在事务中的命令请求，它会把事务中所有的命令都执行完毕才会去执行其他的命令。</p>
<h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p><code>Redis</code>中提供了<code>multi</code>、<code>discard</code>、<code>exec</code>、<code>watch</code>、<code>unwatch</code>这几个命令来实现事务的功能。<br><code>Redis</code>的事务始于<code>multi</code>命令，之后跟着要在事务中执行的命令，终于<code>exec</code>命令或者<code>discard</code>命令。加入事务中的所有命令会原子的执行，中间不会穿插执行其他没有加入事务的命令。</p>
<blockquote>
<p><code>multi</code>、<code>exec</code>和<code>discard</code></p>
</blockquote>
<p><code>multi</code>命令告诉<code>Redis</code>客户端要开始一个事物,然后<code>Redis</code>会返回一个<code>OK</code>，接下来所有的命令<code>Redis</code>都不会立即执行，只会返回<code>QUEUED</code>结果，直到遇到了<code>exec</code>命令才会去执行之前的所有的命令，或者遇到了<code>discard</code>命令，会抛弃执行之前加入事务的命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get gender</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name Slogen</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set gender male</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">127.0.0.1:6379&gt; mget name gender</span><br><span class="line">1) "Slogen"</span><br><span class="line">2) "male"</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>watch</code></p>
</blockquote>
<p><code>watch</code>命令是<code>Redis</code>提供的一个乐观锁，可以在<code>exec</code>执行之前，监视任意数量的数据库<code>key</code>，并在<code>exec</code>命令执行的时候，检测被监视的<code>key</code>是否至少有一个已经被修改，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。</p>
<p>首先在<code>client1</code>执行下列命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; watch name</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name slogen</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set gender male</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>
<p>这个时候<code>client</code>还没有执行<code>exec</code>命令，接下来在<code>client2</code>下执行下面命令修改<code>name</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name rio</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"rio"</span><br></pre></td></tr></table></figure>
<p>接下来在<code>client1</code>下执行<code>exec</code>命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">"rio"</span><br></pre></td></tr></table></figure>
<p>从执行结果可以看到，在<code>client1</code>中执行<code>exec</code>命令的时候，<code>Redis</code>会检测到<code>name</code>字段已经被其他客户端修改了，所以拒绝执行事务中所有的命令，直接返回<code>nil</code>表示执行失败。这个时候获取到的<code>name</code>的值还是在<code>client2</code>中设置的<code>rio</code>。</p>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><blockquote>
<p><code>multi</code></p>
</blockquote>
<p><code>Redis</code>的事务始于<code>multi</code>命令，那么就从<code>multi</code>命令的源代码开始分析。<br>当<code>Redis</code>接收到客户端发送过来的命令之后会执行<code>multiCommand()</code>这个方法，这个方法在<code>multi.c</code>文件中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 如果检测到flags里面已经包含了CLIENT_MULTI</span></span><br><span class="line">    <span class="comment">// 表示对应client已经处于事务的上下文中，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"MULTI calls can not be nested"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 开启flags的CLIENT_MULTI标识</span></span><br><span class="line">    c-&gt;flags |= CLIENT_MULTI;</span><br><span class="line">    <span class="comment">// 3. 返回ok,告诉客户端已经成功开启事务</span></span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源代码中可以看到，<code>multiCommand()</code>主要完成下面三件事:</p>
<ol>
<li>检测发送<code>multi</code>命令的<code>client</code>是否已经处于事务中，如果是则直接返回错误。从这里可以看到，<strong><em><code>Redis</code>不支持事务嵌套执行</em></strong>。</li>
<li>给对应<code>client</code>的<code>flags</code>标志位中增加<code>MULTI_CLIENT</code>标志，表示已经进入事务中。</li>
<li>返回<code>OK</code>告诉客户端已经成功开启事务。</li>
</ol>
<p>从前面的文章中可以知道，<code>Redis</code>接收到所有的<code>Client</code>发送过来的命令后都会执行到<code>processCommand()</code>这个方法中，在<code>processCommand()</code>中有下面这部分代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他省略代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Exec the command */</span></span><br><span class="line">    <span class="comment">// 事物在这里执行</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 把命令加入队列</span></span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued); <span class="comment">// 给客户端返回QUEUED</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnLists();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>processCommand()</code>执行实际的命令之前会先判断对应的<code>client</code>是否已经处于事务的上下文中，如果是的话，且需要执行的命令不是<code>exec</code>、<code>discard</code>、<code>multi</code>和<code>watch</code>这四个命令中的任何一个，则调用<code>queueMultiCommand()</code>方法把需要执行的命令加入队列中，否则的话调用<code>call()</code>直接执行命令。</p>
<blockquote>
<p><code>queueMultiCommand()</code></p>
</blockquote>
<p><code>Redis</code>调用<code>queueMultiCommand()</code>方法把加入事务的命令加入<code>Redis</code>队列中，实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    multiCmd *mc;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// 分配(c-&gt;mstate.count+1)个内存地址,commands指向首地址</span></span><br><span class="line">    <span class="comment">// 并把新加入的命令放置在最后面</span></span><br><span class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</span><br><span class="line">            <span class="keyword">sizeof</span>(multiCmd)*(c-&gt;mstate.count+<span class="number">1</span>));</span><br><span class="line">    mc = c-&gt;mstate.commands+c-&gt;mstate.count;</span><br><span class="line">    mc-&gt;cmd = c-&gt;cmd;</span><br><span class="line">    mc-&gt;argc = c-&gt;argc;</span><br><span class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv,c-&gt;argv,<span class="keyword">sizeof</span>(robj*)*c-&gt;argc);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        incrRefCount(mc-&gt;argv[j]);</span><br><span class="line">    c-&gt;mstate.count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>queueMultiCommand()</code>方法主要是把要加入事务的命令封装在<code>multiCmd</code>结构的变量，然后放置到<code>client-&gt;mstate.commands</code>数组中去，<code>multiCmd</code>的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    robj **argv; <span class="comment">// 命令的参数数组</span></span><br><span class="line">    <span class="keyword">int</span> argc; <span class="comment">// 命令的参数个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span> <span class="comment">// 要执行的命令</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure>
<p>而<code>mstate</code>字段定义为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// 其他省略代码</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure>
<p><code>multiState</code>的结构为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    multiCmd *commands;     <span class="comment">/* Array of MULTI commands */</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">/* Total number of MULTI commands */</span></span><br><span class="line">    <span class="keyword">int</span> minreplicas;        <span class="comment">/* MINREPLICAS for synchronous replication */</span></span><br><span class="line">    <span class="keyword">time_t</span> minreplicas_timeout; <span class="comment">/* MINREPLICAS timeout as unixtime. */</span></span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>commands</code>:<code>multiCmd</code>类型的数组，存放着事务中所有的要执行的命令</li>
<li><code>count</code>:当前事务中所有已经存放的命令的个数</li>
</ul>
<p>另外两个字段当前版本中(3.2.28)没用上。<br>假设当前事务队列中已经存在<code>set name slogen</code>和<code>lpush num 20</code>这两个命令的时候，<code>client</code>中的<code>mstate</code>的数据如下:</p>
<p><img src="https://i.loli.net/2018/11/16/5bee3f86d1eeb.png" alt="`commands`"></p>
<p>这个时候再往事务中添加<code>get name</code>这个命令的时候结构图如下:</p>
<p><img src="https://i.loli.net/2018/11/16/5bee3fabd0e6d.png" alt="commandsnew"></p>
<blockquote>
<p>错误命令:<code>CLIENT_DIRTY_EXEC</code></p>
</blockquote>
<p>那么有个问题，比如我往事务中添加的命令是个不存在的命令，或者命令使用方式，比如命令参数不对，这个时候这个命令会被加入事务吗？<br>前面说了，<code>Redis</code>接收到的所有的命令都是执行到<code>processCommand()</code>这个方法，在实际执行对应的命令前，<code>processCommand()</code>方法都会对将要执行的命令进行一系列的检查，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他省略代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到那么对应的redisCommand数据</span></span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;cmd) &#123;</span><br><span class="line">        <span class="comment">// 没有找到命令</span></span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        addReplyErrorFormat(c,<span class="string">"unknown command '%s'"</span>,</span><br><span class="line">            (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c-&gt;cmd-&gt;arity &gt; <span class="number">0</span> &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</span><br><span class="line">               (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) &#123;</span><br><span class="line">        <span class="comment">// 命令参数不对</span></span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        addReplyErrorFormat(c,<span class="string">"wrong number of arguments for '%s' command"</span>,</span><br><span class="line">            c-&gt;cmd-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the user is authenticated */</span></span><br><span class="line">    <span class="comment">// 对应的命令是否需要认证</span></span><br><span class="line">    <span class="keyword">if</span> (server.requirepass &amp;&amp; !c-&gt;authenticated &amp;&amp; c-&gt;cmd-&gt;proc != authCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        addReply(c,shared.noautherr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他省略代码</span></span><br><span class="line">    <span class="comment">// 对要执行的命令进行其他的检测，检测失败的话</span></span><br><span class="line">    <span class="comment">// 都会调用flagTransaction()函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，<code>processCommand()</code>在对要执行的命令进行的一系列检查的时候如果有任何一项检测失败都会调用<code>flagTransaction()</code>函数然后返回对应的信息给客户端，<code>flagTransaction()</code>实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flagTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI)</span><br><span class="line">        <span class="comment">// 如果flags包含CLIENT_MULTI标志位，表示已经处于事务上下文中</span></span><br><span class="line">        <span class="comment">// 则给对应的client的flags开启CLIENT_DIRTY_EXEC标志位</span></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_EXEC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flagTransaction()</code>方法会检测对应的<code>client</code>是否处于事务的上下文中，如果是的话就给对应的<code>client</code>的<code>flags</code>字段开启<code>CLIENT_DIRTY_EXEC</code>标志位。<br>也就是说，如果命令在加入事务的时候由于各种原因，比如命令不存在，或者对应的命令参数不正确，则对应的命令不会被添加到<code>mstate.commands</code>数组中，且同时给对应的<code>client</code>的<code>flags</code>字段开启<code>CLIENT_DIRTY_EXEC</code>标志位。</p>
<blockquote>
<p><code>watch</code>命令</p>
</blockquote>
<p>当<code>client</code>处于事务的上下文中时，<code>watch</code>命令属于可以被立即执行的几个命令之一,<code>watch</code>命令对应的代码为<code>watchCommand()</code>函数，实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        <span class="comment">// 如果执行watch命令的client处于事务的上下文中则直接返回</span></span><br><span class="line">        addReplyError(c,<span class="string">"WATCH inside MULTI is not allowed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        <span class="comment">// 对传入的每个要watch的可以调用watchForKey()</span></span><br><span class="line">        watchForKey(c,c-&gt;argv[j]);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>watchCommand()</code>方法会首先判断执行<code>watch</code>的命令是否已经处于事务的上下文中，如果是的话则直接报错返回，说明<strong><em>在<code>Redis</code>事务中不能调用<code>watch</code>命令</em></strong>。<br>接下来对于<code>watch</code>命令传入的所有的<code>key</code>，依次调用<code>watchForKey()</code>方法，定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchForKey</span><span class="params">(client *c, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    watchedKey *wk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key */</span></span><br><span class="line">    listRewind(c-&gt;watched_keys,&amp;li);</span><br><span class="line">    <span class="comment">// 1. 先检查对应的key是否已经存在于watch列表中</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        wk = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">if</span> (wk-&gt;db == c-&gt;db &amp;&amp; equalStringObjects(key,wk-&gt;key))</span><br><span class="line">            <span class="comment">// 对应的key已经存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* Key already watched */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* This key is not already watched in this DB. Let's add it */</span></span><br><span class="line">    <span class="comment">// 2. 根据key的名字查找所有watch了这个key的client对象</span></span><br><span class="line">    <span class="comment">// 如果还没有任何一个client在watch这个key,则把对应的client</span></span><br><span class="line">    <span class="comment">// 添加到redisDb-&gt;watched_keys列表中，键是对应的key</span></span><br><span class="line">    clients = dictFetchValue(c-&gt;db-&gt;watched_keys,key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) &#123;</span><br><span class="line">        clients = listCreate();</span><br><span class="line">        <span class="comment">// 添加到redisSb-&gt;watched_keys保存，键为key </span></span><br><span class="line">        dictAdd(c-&gt;db-&gt;watched_keys,key,clients);</span><br><span class="line">        incrRefCount(key);</span><br><span class="line">    &#125;</span><br><span class="line">    listAddNodeTail(clients,c);</span><br><span class="line">    <span class="comment">/* Add the new key to the list of keys watched by this client */</span></span><br><span class="line">    <span class="comment">// 3. 构造watchedKey对象，并添加到client-&gt;watched_keys列表的最后    </span></span><br><span class="line">    wk = zmalloc(<span class="keyword">sizeof</span>(*wk));</span><br><span class="line">    wk-&gt;key = key;</span><br><span class="line">    wk-&gt;db = c-&gt;db;</span><br><span class="line">    incrRefCount(key);</span><br><span class="line">    listAddNodeTail(c-&gt;watched_keys,wk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>watchForKey()</code>方法会做下面几件事:</p>
<ol>
<li>判断对应的<code>key</code>是否已经存在于<code>client-&gt;watched_keys</code>列表中，如果已经存在则直接返回。<code>client-&gt;watched_keys</code>保存着对应的<code>client</code>对象所有的要监视的<code>key</code>。</li>
<li>如果不存在，则去<code>client-&gt;db-&gt;watched_keys</code>中查找所有的已经监视了这个<code>key</code>的<code>client</code>对象。<code>client-&gt;db-&gt;watched_keys</code>以<code>dict</code>的结构保存了所有的监视这个<code>key</code>的<code>client</code>列表。</li>
<li>如果第二步中的列表存在，则把执行<code>watch</code>命令的<code>client</code>添加到这个列表的尾部，如果不存在，表示还没有任何一个<code>client</code>监视这个<code>key</code>,则新建一个列表，添加到<code>client-&gt;db-&gt;watched_keys</code>中，然后把执行<code>watch</code>命令的<code>client</code>添加到新生成的列表的尾部。</li>
<li>把传入的<code>key</code>封装成一个<code>watchedKey</code>结构的变量，添加到<code>client-&gt;watched_key</code>列表的最后面。</li>
</ol>
<p>假设当前<code>client-&gt;db-&gt;watched_keys</code>的监测情况如下图所示:</p>
<p><img src="https://i.loli.net/2018/11/16/5bee405d99bc9.png" alt="watched"></p>
<p>而<code>client-&gt;watched_keys</code>的监测情况如下:</p>
<p><img src="https://i.loli.net/2018/11/16/5bee4085be7b0.png" alt="client_watched_keys"></p>
<p>这个时候<code>client_A</code>执行<code>watch key1 key2 key3</code>这个命令，执行完命令之后<code>client-&gt;db-&gt;watched_keys</code>结果为</p>
<p><img src="https://i.loli.net/2018/11/16/5bee40c9c8d03.png" alt="newwatched"></p>
<p>而<code>client-&gt;watched_keys</code>结果为</p>
<p><img src="https://i.loli.net/2018/11/16/5bee40f849cf6.png" alt="clientNewWatched"></p>
<p>对于<code>key1</code>,目前还没有<code>client</code>对<code>key1</code>进行监视，所以这个时候<code>client_A</code>会新建一个列表，把自己添加到这个列表中然后把映射关系添加到<code>client-&gt;db-&gt;watched_keys</code>中去，之后会把<code>key1</code>添加到<code>client-&gt;watched_keys</code>列表的最后。<br>对于<code>key2</code>，由于已经存在于<code>watched_keys</code>列表中，所以会直接返回不做任何处理。<br>对于<code>key3</code>，由于<code>client-&gt;db-&gt;watched_keys</code>中已经有<code>client_B</code>和<code>client_C</code>在监视它，所以会直接把<code>client_A</code>添加到监视列表的末尾之后再把<code>key3</code>添加到<code>client_A</code>的监视列表中去。</p>
<blockquote>
<p>修改数据:<code>CLIENT_DIRTY_CAS</code></p>
</blockquote>
<p><code>watch</code>命令的作用就是用在事务中检测被监视的<code>key</code>是否被其他的<code>client</code>修改了，如果已经被修改，则阻止事务的执行，那么这个功能是怎么实现的呢？<br>这里以<code>set</code>命令为例进行分析。<br>假设<code>client_A</code>执行了<code>watch name</code>这个命令然后执行<code>multi</code>命令开启了事务但是还没有执行<code>exec</code>命令，这个时候<code>client_B</code>执行了<code>set name slogen</code>这个命令,整个过程如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">时间</th>
<th style="text-align:center">client_A</th>
<th style="text-align:center">client_B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>T1</code></td>
<td style="text-align:center"><code>watch name</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>T2</code></td>
<td style="text-align:center"><code>multi</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>T3</code></td>
<td style="text-align:center"><code>get name</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>T4</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"><code>set name slogen</code></td>
</tr>
<tr>
<td style="text-align:center"><code>T5</code></td>
<td style="text-align:center"><code>exec</code></td>
</tr>
</tbody>
</table>
<p>在<code>T4</code>的时候<code>client_B</code>执行了<code>set</code>命令修改了<code>name</code>,<code>Redis</code>收到<code>set</code>命令之后会执行<code>setCommand</code>方法，实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他省略代码</span></span><br><span class="line">    setGenericCommand(c,flags,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],expire,unit,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>setCommand()</code>最后会调用<code>setGenericCommand()</code>方法，改方法实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags, robj *key, robj *val, robj *expire, <span class="keyword">int</span> unit, robj *ok_reply, robj *abort_reply)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他省略代码</span></span><br><span class="line">    setKey(c-&gt;db,key,val);</span><br><span class="line">    <span class="comment">// 其他省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>setGenericCommand()</code>方法中会调用<code>setKey()</code>这个方法，接着看下<code>setKey()</code>这个方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lookupKeyWrite(db,key) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dbAdd(db,key,val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbOverwrite(db,key,val);</span><br><span class="line">    &#125;</span><br><span class="line">    incrRefCount(val);</span><br><span class="line">    removeExpire(db,key);</span><br><span class="line">    <span class="comment">// 通知修改了key</span></span><br><span class="line">    signalModifiedKey(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>setKey()</code>方法最后会调用<code>signaleModifiedKey()</code>通知<code>redis</code>数据库中有数据被修改,<code>signaleModifiedKey()</code>方法实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalModifiedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    touchWatchedKey(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>signalModifiedKey()</code>也仅仅是调用<code>touchWatchedKey()</code>方法，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touchWatchedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 1. 从redisDb-&gt;watched_keys中找到对应的client列表</span></span><br><span class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark all the clients watching this key as CLIENT_DIRTY_CAS */</span></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key */</span></span><br><span class="line">    listRewind(clients,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        <span class="comment">// 2.依次遍历client列表，给每个client的flags字段</span></span><br><span class="line">        <span class="comment">// 开启CLIENT_DIRTY_CAS标识位</span></span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_CAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>touchWatchedKey()</code>方法会做下面两件事:</p>
<ol>
<li>从<code>redisDb-&gt;watched_keys</code>中找到监视这个<code>key</code>的client列表。前面在分析<code>watch</code>命令的时候说过，如果有<code>client</code>执行了<code>watch keys</code>命令，那么<code>redis</code>会以键值对的形式把<code>(key,client)</code>的对应关系保存在<code>redisDb-&gt;watched_key</code>这个字段里面。</li>
<li>对于第一步中找到的每个<code>client</code>对象，都会给这个<code>client</code>的<code>flags</code> 字段开启<code>CLIENT_DIRTY_CAS</code>标志位。</li>
</ol>
<p>在<code>Redis</code>里面所有会修改数据库内容的命令最后都会调用<code>signalModifiedKey()</code>这个方法，而在<code>signalModifiedKey()</code>会给所有的监视这个<code>key</code>的<code>client</code>增加<code>CLIENT_DIRTY_CAS</code>标志位。</p>
<blockquote>
<p><code>exec</code>命令</p>
</blockquote>
<p><code>exec</code>命令用来执行事务，对应的代码为<code>execCommand()</code>这个方法，实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj **orig_argv;</span><br><span class="line">    <span class="keyword">int</span> orig_argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">orig_cmd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> must_propagate = <span class="number">0</span>; <span class="comment">/* Need to propagate MULTI/EXEC to AOF / slaves? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 判断对应的client是否属于事务中</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"EXEC without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 检查是否需要执行事务，在下面两种情况下不会执行事务</span></span><br><span class="line"><span class="comment">     * 1) 有被watch的key被其他的客户端修改了，对应于CLIENT_DIRTY_CAS标志位被开启</span></span><br><span class="line"><span class="comment">     * ,这个时候会返回一个nil，表示没有执行事务</span></span><br><span class="line"><span class="comment">     * 2) 有命令在加入事务队列的时候发生错误，对应于CLIENT_DIRTY_EXEC标志位被开启</span></span><br><span class="line"><span class="comment">     * ,这个时候会返回一个execaborterr错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC)) &#123;</span><br><span class="line">        addReply(c, c-&gt;flags &amp; CLIENT_DIRTY_EXEC ? shared.execaborterr :</span><br><span class="line">                                                  shared.nullmultibulk);</span><br><span class="line">        <span class="comment">// 取消所有的事务</span></span><br><span class="line">        discardTransaction(c);</span><br><span class="line">        <span class="keyword">goto</span> handle_monitor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exec all the queued commands */</span></span><br><span class="line">    <span class="comment">// 3. unwatch所有被这个client watch的key</span></span><br><span class="line">    unwatchAllKeys(c); <span class="comment">/* Unwatch ASAP otherwise we'll waste CPU cycles */</span></span><br><span class="line">    orig_argv = c-&gt;argv;</span><br><span class="line">    orig_argc = c-&gt;argc;</span><br><span class="line">    orig_cmd = c-&gt;cmd;</span><br><span class="line">    addReplyMultiBulkLen(c,c-&gt;mstate.count);</span><br><span class="line">    <span class="comment">// 4. 依次执行事务队列中所有的命令</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line">        c-&gt;argc = c-&gt;mstate.commands[j].argc;</span><br><span class="line">        c-&gt;argv = c-&gt;mstate.commands[j].argv;</span><br><span class="line">        c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Propagate a MULTI request once we encounter the first write op.</span></span><br><span class="line"><span class="comment">         * This way we'll deliver the MULTI/..../EXEC block as a whole and</span></span><br><span class="line"><span class="comment">         * both the AOF and the replication link will have the same consistency</span></span><br><span class="line"><span class="comment">         * and atomicity guarantees. */</span></span><br><span class="line">        <span class="keyword">if</span> (!must_propagate &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_READONLY)) &#123;</span><br><span class="line">            execCommandPropagateMulti(c);</span><br><span class="line">            must_propagate = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Commands may alter argc/argv, restore mstate. */</span></span><br><span class="line">        c-&gt;mstate.commands[j].argc = c-&gt;argc;</span><br><span class="line">        c-&gt;mstate.commands[j].argv = c-&gt;argv;</span><br><span class="line">        c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    c-&gt;argv = orig_argv;</span><br><span class="line">    c-&gt;argc = orig_argc;</span><br><span class="line">    c-&gt;cmd = orig_cmd;</span><br><span class="line">    <span class="comment">// 5. 重置这个client对应的事务相关的所有的数据</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line">    <span class="comment">/* Make sure the EXEC command will be propagated as well if MULTI</span></span><br><span class="line"><span class="comment">        * was already propagated. */</span></span><br><span class="line">    <span class="keyword">if</span> (must_propagate) server.dirty++;</span><br><span class="line"></span><br><span class="line">handle_monitor:</span><br><span class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp; !server.loading)</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>execCommand()</code>方法会做下面几件事:</p>
<ol>
<li>判断对应的<code>client</code>是否已经处于事务中，如果不是，则直接返回错误。</li>
<li>判断时候需要执行事务中的命令。在下面两种情况下不会执行事务而是返回错误。<ol>
<li>有被监视的<code>key</code>被其他的客户端修改了，对应于<code>CLIENT_DIRTY_CAS</code>标志位被开启，这个时候会返回一个<code>nil</code>，表示没有执行事务。</li>
<li>有命令在加入事务队列的时候发生错误，对应于CLIENT_DIRTY_EXEC标志位被开启，这个时候会返回一个<code>execaborterr</code>错误。</li>
</ol>
</li>
<li><code>unwatch</code>所有被这个<code>client</code>监视的<code>key</code>。</li>
<li>依次执行事务队列中所有的命令。</li>
<li>重置这个<code>client</code>对应的事务相关的所有的数据。</li>
</ol>
<blockquote>
<p><code>discard</code></p>
</blockquote>
<p>使用<code>discard</code>命令可以取消一个事务，对应的方法为<code>discardCommand()</code>,实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查对应的client是否处于事务中</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"DISCARD without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 取消事务</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>discardCommand()</code>方法首先判断对应的<code>client</code>是否处于事务中，如果不是则直接返回错误，否则的话会调用<code>discardTransaction()</code>方法取消事务，该方法实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 释放所有跟MULTI/EXEC状态相关的资源    </span></span><br><span class="line">    freeClientMultiState(c);</span><br><span class="line">    <span class="comment">// 2. 初始化相应的状态</span></span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    <span class="comment">// 3. 取消对应client的3个标志位</span></span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_MULTI|CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC);</span><br><span class="line">    <span class="comment">// 4.unwatch所有已经被watch的key</span></span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><blockquote>
<p><code>Atomic</code>:原子性</p>
</blockquote>
<p>原子性是指一个事务（<code>transaction</code>）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。<br>对于<code>Redis</code>的事务来说，事务队列中的命令要么全部执行完成，要么一个都不执行，因此<strong><em><code>Redis</code>的事务是具有原子性的</em></strong>。<br>注意<strong><em><code>Redis</code>不提供事务回滚机制</em></strong>。</p>
<blockquote>
<p><code>Consistency</code>:一致性</p>
</blockquote>
<p>事务的一致性是指事务的执行结果必须是使事务从一个一致性状态变到另一个一致性状态，无论事务是否执行成功。</p>
<ol>
<li>命令加入事务队列失败(参数个数不对？命令不存在?)，整个事务不会执行。所以事务的一致性不会被影响。</li>
<li>使用了<code>watch</code>命令监视的<code>key</code>只事务期间被其他客户端修改，整个事务不会执行。也不会影响事务的一致性。</li>
<li>命令执行错误。如果事务执行过程中有一个活多个命令错误执行失败，服务器也不会中断事务的执行，会继续执行事务中剩下的命令，并且已经执行的命令不会受任何影响。出错的命令将不会执行，也就不会对数据库做出修改，因此这种情况下事物的一致性也不会受到影响。</li>
<li><p>服务器宕机。服务器宕机的情况下的一致性可以根据服务器使用的持久化方式来分析。</p>
<ol>
<li>无持久化模式下，事务是一致的。这种情况下重启之后的数据库没有任何数据，因此总是一致的。</li>
<li><code>RDB</code>模式下，事务也是一致的。服务器宕机重启之后可以根据<code>RDB</code>文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可以使用的<code>RDB</code>文件，那么重启之后数据库是空白的，那也是一致的。</li>
<li><code>AOF</code>模式下，事务也是一致的。服务器宕机重启之后可以根据<code>AOF</code>文件来恢复数据，从而将数据库还原到一个一直的状态。如果找不到可以使用的<code>AOF</code>文件，那么重启之后数据库是空白的，那么也是一致的。</li>
</ol>
</li>
</ol>
<blockquote>
<p><code>Isolation</code>:隔离性 </p>
</blockquote>
<p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
<blockquote>
<p><code>Durability</code>:持久性</p>
</blockquote>
<p><code>Redis</code>事务并没有提供任何的持久性功能，所以事务的持久性是由<code>Redis</code>本身所使用的持久化方式来决定的。</p>
<ul>
<li>在单纯的内存模式下，事务肯定是不持久的。</li>
<li>在<code>RDB</code>模式下，服务器可能在事务执行之后<code>RDB</code>文件更新之前的这段时间失败，所以<code>RDB</code>模式下的<code>Redis</code>事务也是不持久的。</li>
<li>在<code>AOF</code>的<code>always</code>模式下，事务的每条命令在执行成功之后，都会立即调用<code>fsync</code>或<code>fdatasync</code>将事务数据写入到<code>AOF</code>文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</li>
<li>其他<code>AOF</code>模式也和<code>always</code>模式类似，所以它们都是不持久的。</li>
</ul>
<p><strong><em>结论：<code>Redis</code>的事务满足原子性、一致性和隔离性，但是不满足持久性。</em></strong>。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><code>Redis</code>源码(3.2.28)</li>
<li>《Redis设计与实现》<br>173.247.232.27</li>
</ol>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>万一打赏了呢^_^</div>
  <button id="rewardButton" disable="enable" style="width: 80px;line-height: 38px;text-align: center;font-weight: bold;color: #fff;border-radius: 5px;
margin:0 20px 20px 0;position: relative;overflow: hidden;color: #8c96a0;text-shadow:1px 1px 1px #fff;border:1px solid #dce1e6;box-shadow: 0 1px 2px #fff inset,0 -1px 0 #a8abae inset;background: -webkit-linear-gradient(top,#f2f3f7,#e4e8ec);background: -moz-linear-gradient(top,#f2f3f7,#e4e8ec);background: linear-gradient(top,#f2f3f7,#e4e8ec);" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    打赏
  </button>
  <div id="QR" style="display: none;">
    
      <div id="wechat" style="display: inline-block;width:150px;height:150px">
        <img id="wechat_qr" src="/uploads/wechatpay.jpeg" alt="Slogen WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    
    
      <div id="alipay" style="display: inline-block;width:150px;height:150px">
        <img id="alipay_qr" src="/uploads/alipay.jpeg" alt="Slogen Alipay">
        <p>Alipay</p>
      </div>
    
    
  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/源码分析/" rel="tag"># 源码分析</a>
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/10/CLion调试Redis5源码/" rel="next" title="CLion调试Redis5源码">
                <i class="fa fa-chevron-left"></i> CLion调试Redis5源码
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/11/时间波之时间裂缝说/" rel="prev" title="时间波之时间裂缝说">
                时间波之时间裂缝说 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpeg" alt="Slogen">
            
              <p class="site-author-name" itemprop="name">Slogen</p>
              <p class="site-description motion-element" itemprop="description">不骄不躁，韬光养晦。荣辱不惊，厚积薄发。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#What"><span class="nav-number">1.</span> <span class="nav-text">What</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#How"><span class="nav-number">2.</span> <span class="nav-text">How</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Why"><span class="nav-number">3.</span> <span class="nav-text">Why</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Other"><span class="nav-number">4.</span> <span class="nav-text">Other</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference"><span class="nav-number">5.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Slogen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Bb4EcKhqq3La7xJ59ip4Yv8W-gzGzoHsz',
        appKey: 'LpDWAjNpYUPqyA8rRfxDqfKD',
        placeholder: '指点江山，激扬文字',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
